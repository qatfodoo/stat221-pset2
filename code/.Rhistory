J <- 1000
N <- 2
weights <- rep(1, J) # equal weights
mu <- c(1.6, 2.5, 5.2, 4.9)
sigsq <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
for (b.theta in 1:B.theta) {
print(b.theta)
}
# Simulation parameters
B <- 1000 # Number of simulations
B.theta <- 40 # theta drawss
B.y <- 25 # y draws for each theta
for (b.theta in 1:B.theta) {
print(b.theta)
}
floor(4.5)
?rnorm
mu
length(mu)
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
sqrt(4)
J
i <- 1
mu <- mu.array[i]
sigsq <- sigsq.array[i]
log.theta <- rnorm(J, mu, sqrt(sigsq))
log.theta
log.theta_array <- c() # Store log.theta values
sys.time()
Sys.time()
a <- simYgivenTheta
a <- Sys.time()
b <- Sys.time()
b - a
int(b - a)
as.numeric(b - a)
paste("fwe", "Wefewf")
paste("fwe", "Wefewf", sep=":")
paste("fwe", "Wefewf", sep=": ")
t1.ov <- Sys.time()
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": ")
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
Y
w
poisson.logn.mcmc(Y, w)
Y
theta
w
N
Y <- simYgivenTheta(theta, w, N)
w
w
mcmc <- poisson.logn.mcmc(Y, w)
# Constants
J <- 1000
N <- 2
w <- rep(1, J) # equal weights
# Simulation parameters
B <- 1000 # Number of simulations
B.theta <- 40 # theta drawss
B.y <- floor(B / B.theta) # y draws for each theta
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
log.theta_array <- c() # Store log.theta values
i <- 1
mu <- mu.array[i]
sigsq <- sigsq.array[i]
mu
sigsq
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_array <- c(log.theta_array, log.theta)
theta <- exp(log.theta)
theta
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
mcmc
mcmc[[1]]
mcmc$Y
Y
mcmc$w
mcmc$ndraws
mcmc$burnin
mcmc$mu
length(mcmc$mu)
mcmc$sigmasq
mcmc$logTheta
length(mcmc$logTheta)
length(mcmc$mu)
N
J * N
mcmc$logTheta[[1]]
mcmc$logTheta[[2]]
mcmc$logTheta[1
mcmc$logTheta[1]
mcmc$logTheta
mcmc$logTheta[1, ]
length(mcmc$logTheta[1, ])
length(mcmc$logTheta[, 1])
# Constants
J <- 1000
N <- 2
w <- rep(1, J) # equal weights
# Simulation parameters
B <-1 #1000 # Number of simulations
B.theta <- 1 #40 # theta drawss
B.y <- floor(B / B.theta) # y draws for each theta
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
log.theta_array <- c() # Store log.theta values
# Constants
J <- 1000
N <- 2
w <- rep(1, J) # equal weights
# Simulation parameters
B <-1 #1000 # Number of simulations
B.theta <- 1 #40 # theta drawss
B.y <- floor(B / B.theta) # y draws for each theta
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
log.theta_array <- c() # Store log.theta values
t1.ov <- Sys.time()
for (i in 1:1) { #length(mu)) {
# Set current model constant hyperparameters
mu <- mu.array[i]
sigsq <- sigsq.array[i]
# Draw set of thetas
t1.sim <- Sys.time()
for (b.theta in 1:B.theta) {
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_array <- c(log.theta_array, log.theta)
theta <- exp(log.theta)
# Draw set of Y for current theta
t1.mcmc <- Sys.time()
for (b.y in 1:B.y) {
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
logTheta.post <- mcmc$logTheta
}
t2.mcmc <- Sys.time()
dt.mcmc <- t2.mcmc - t1.mcmc
print(paste("Current theta MCMC elapsed time", dt.mcmc, sep=": "))
print(b.theta)
}
t2.sim <- Sys.time()
dt.sim <- t2.sim - t1.sim
print(paste("Simulation elapsed time", dt.sim, sep=": "))
}
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
log.theta_array
type(1)
typeof(1)
typeof(logTheta.post)
logTheta.post
typeof(logTheta.post)
?matrix
log.theta_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store log.theta values
dim(log.theta_mat)
log.theta
log.theta_mat[, b.theta] <- log.theta
log.theta_mat
theta
set.seed(42) M <- matrix(rnorm(40),ncol=4)
R> apply(M, 2, sd)
set.seed(42;) M <- matrix(rnorm(40),ncol=4);
apply(M, 2, sd)
set.seed(42); M <- matrix(rnorm(40),ncol=4);
apply(M, 2, sd)
M
set.seed(42); M <- matrix(rnorm(40),ncol=4);
apply(M, 2, sd)
set.seed(42); M <- matrix(rnorm(40),ncol=4);
apply(M, 1, sd)
set.seed(42); M <- matrix(rnorm(40),ncol=4);
apply(M, 2, sd)
set.seed(42); M <- matrix(rnorm(40),ncol=4);
apply(M, 1, sd)
logTheta.draws <- mcmc$logTheta
logTheta.postmean <- apply(logTheta.draws, 1, mean)
logTheta.postmean
length(logTheta.postmean)
log.Theta.postsd <- apply(logTheta.draws, 1, sd)
log.Theta.postsd
mcmc$sigmasq
mcmc$sigmasq[1]
log.Theta.postsd[1]
0.4553839^2
mcmc$sigmasq[2]
mcmc$sigmasq[3]
replicate(10, diag(2), simplify=F)
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
# log.theta and corresponding coverage
log.theta_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store log.theta values
log.theta_mean <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior means of draws
log.theta_sd <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior sd of drawslog.theta_mean
cov_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store frequency coverage for thetas
t1.ov <- Sys.time()
for (i in 1:1) { #length(mu)) {
# Set current model constant hyperparameters
mu <- mu.array[i]
sigsq <- sigsq.array[i]
# Draw set of thetas
t1.sim <- Sys.time()
for (b.theta in 1:B.theta) {
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_mat[, b.theta] <- log.theta
theta <- exp(log.theta)
# Draw set of Y for current theta
t1.mcmc <- Sys.time()
for (b.y in 1:B.y) {
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
logTheta.draws <- mcmc$logTheta
log.theta_mean[[b.theta]][, b.y] <- apply(logTheta.draws, 1, mean)
log.theta_sd[[b.theta]][, b.y] <- apply(logTheta.draws, 1, sd)
}
t2.mcmc <- Sys.time()
dt.mcmc <- t2.mcmc - t1.mcmc
print(paste("Current theta MCMCs elapsed time", dt.mcmc, sep=": "))
print(b.theta)
}
t2.sim <- Sys.time()
dt.sim <- t2.sim - t1.sim
print(paste("Simulation elapsed time", dt.sim, sep=": "))
}
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
log.theta_mean
log.theta_sd
logTheta.draws[1, ]
a <- logTheta.draws[1, ]
length(a)
quantile(a, probs=c(0.025, 0.975))
?sapply
logTheta.draws
log.theta_mean[[b.theta]][, b.y] <- sapply(logTheta.draws, 1, mean) # Store sample means
quantile(a, probs=c(0.025, 0.975))
post.int_95 <- apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) })
post.int_95
post.int_95[1, ]
post.int_95[, 1]
post.int_95[, 2]
post.int_95[, 3]
post.int_95[, 4]
100 - 84
68 + 31
68 + 32
log.theta
length(log.theta)
log.theta < post.int_68[, 1]
# Derive 68% and 95% poterior intervals
post.int_68 <- apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.16, 0.84)) })
post.int_95 <- apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) })
log.theta < post.int_68[, 1]
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) && (log.theta <= post.int_68[, 1])
(log.theta >= post.int_68[, 1]) && (log.theta <= post.int_68[, 1])
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1])
sum((log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1]))
sum((log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1]))
sum((log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1]) == TRUE)
sum((log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1]))
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1])
(log.theta >= post.int_68[, 1]) && (log.theta <= post.int_68[, 1])
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
post.int[, 1]
post.int_68[, 1]
post.int_68[1, ]
dim(post.int_68)
post.int_68 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.16, 0.84)) }))
dim(post.int_68)
post.int_95 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) }))
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1])
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 1])
post.int_68[, 1]
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
(log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
logTheta.cov_68 <- matrix(data=0, nrow=J, ncol= B.y) # Store 68% coverage for thetas
logTheta.cov_95 <- matrix(data=0, nrow=J, ncol= B.y) # Store 95% coverage for theta
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
logTheta.cov_68
a <- cbind(logTheta.cov_68, logTheta.cov_68)
a
apply(a, 1, mean)
# log.theta and corresponding coverage
log.theta_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store log.theta values
log.theta_mean <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior means of draws
log.theta_sd <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior sd of drawslog.theta_mean
cov68_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 68% frequency coverage for thetas
cov95_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 95% frequency coverage for theta
t1.ov <- Sys.time()
for (i in 1:1) { #length(mu)) {
# Set current model constant hyperparameters
mu <- mu.array[i]
sigsq <- sigsq.array[i]
# Draw set of thetas
t1.sim <- Sys.time()
for (b.theta in 1:B.theta) {
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_mat[, b.theta] <- log.theta
theta <- exp(log.theta)
logTheta.cov_68 <- matrix(data=0, nrow=J, ncol= B.y) # Store 68% coverage for thetas
logTheta.cov_95 <- matrix(data=0, nrow=J, ncol= B.y) # Store 95% coverage for theta
# Draw set of Y for current theta
t1.mcmc <- Sys.time()
for (b.y in 1:B.y) {
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
logTheta.draws <- mcmc$logTheta # Sample draws
log.theta_mean[[b.theta]][, b.y] <- apply(logTheta.draws, 1, mean) # Store sample means
log.theta_sd[[b.theta]][, b.y] <- apply(logTheta.draws, 1, sd) # Store sample sd
# Derive 68% and 95% poterior intervals
post.int_68 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.16, 0.84)) }))
post.int_95 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) }))
# Store current coverage
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
logTheta.cov_95[, b.y] <- (log.theta >= post.int_95[, 1]) & (log.theta <= post.int_95[, 2])
}
t2.mcmc <- Sys.time()
dt.mcmc <- t2.mcmc - t1.mcmc
print(paste("Current theta MCMCs elapsed time", dt.mcmc, sep=": "))
# Compute frequency coverage for log.theta
cov68_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
cov95_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
}
t2.sim <- Sys.time()
dt.sim <- t2.sim - t1.sim
print(paste("Simulation elapsed time", dt.sim, sep=": "))
}
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
cov68_mat
cov95_mat
log.theta_sd
log.theta_sd[[1]]
log.theta_sd[[2]]
log.theta_mean[[1]]
log.theta_mat
?save
save(list=c("log.theta_mat", "log.theta_mean", "log.theta_sd",
"cov68_mat", "cov95_mat"), file="/out/task3_out.Rdata")
save(list=c("log.theta_mat", "log.theta_mean", "log.theta_sd",
"cov68_mat", "cov95_mat"), file="./out/task3_out.Rdata")
load("/home/kevkwat/Documents/Harvard/Stats/STAT221/HW 2/stat221-pset2/code/out/task3_out.Rdata")
ls(list=rm())
ls(list=rm())
rm(list=ls())
load("/home/kevkwat/Documents/Harvard/Stats/STAT221/HW 2/stat221-pset2/code/out/task3_out.Rdata")
log.theta_mean
log.theta_sd
source("poissonLogN_MCMC.R")
source("kuatefodouop_ps2_task2.R")
## Task 3: Evaluate coverage for a simple case
# Constants
J <- 1000
N <- 2
w <- rep(1, J) # equal weights
# Simulation parameters
B <-10 #1000 # Number of simulations
B.theta <- 1 #40 # theta drawss
B.y <- floor(B / B.theta) # y draws for each theta
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
# log.theta and corresponding coverage
log.theta_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store log.theta values
log.theta_mean <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior means of draws
log.theta_sd <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior sd of drawslog.theta_mean
cov68_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 68% frequency coverage for thetas
cov95_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 95% frequency coverage for theta
t1.ov <- Sys.time()
for (i in 1:1) { #length(mu)) {
# Set current model constant hyperparameters
mu <- mu.array[i]
sigsq <- sigsq.array[i]
# Draw set of thetas
t1.sim <- Sys.time()
for (b.theta in 1:B.theta) {
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_mat[, b.theta] <- log.theta
theta <- exp(log.theta)
logTheta.cov_68 <- matrix(data=0, nrow=J, ncol= B.y) # Store 68% coverage for thetas
logTheta.cov_95 <- matrix(data=0, nrow=J, ncol= B.y) # Store 95% coverage for theta
# Draw set of Y for current theta
t1.mcmc <- Sys.time()
for (b.y in 1:B.y) {
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
logTheta.draws <- mcmc$logTheta # Sample draws
log.theta_mean[[b.theta]][, b.y] <- apply(logTheta.draws, 1, mean) # Store sample means
log.theta_sd[[b.theta]][, b.y] <- apply(logTheta.draws, 1, sd) # Store sample sd
# Derive 68% and 95% poterior intervals
post.int_68 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.16, 0.84)) }))
post.int_95 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) }))
# Store current coverage
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
logTheta.cov_95[, b.y] <- (log.theta >= post.int_95[, 1]) & (log.theta <= post.int_95[, 2])
}
t2.mcmc <- Sys.time()
dt.mcmc <- t2.mcmc - t1.mcmc
print(paste("Current theta MCMCs elapsed time", dt.mcmc, sep=": "))
# Compute frequency coverage for log.theta
cov68_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
cov95_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
}
t2.sim <- Sys.time()
dt.sim <- t2.sim - t1.sim
print(paste("Simulation elapsed time", dt.sim, sep=": "))
}
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
# Store results in output folder
save(list=c("log.theta_mat", "log.theta_mean", "log.theta_sd",
"cov68_mat", "cov95_mat"), file="./out/task3_out.Rdata")
cov68_mat
dt.ov
source("poissonLogN_MCMC.R")
source("kuatefodouop_ps2_task2.R")
## Task 3: Evaluate coverage for a simple case
# Constants
J <- 1000
N <- 2
w <- rep(1, J) # equal weights
# Simulation parameters
B <-5 #1000 # Number of simulations
B.theta <- 1 #40 # theta drawss
B.y <- floor(B / B.theta) # y draws for each theta
mu.array <- c(1.6, 2.5, 5.2, 4.9)
sigsq.array <- c(0.7^2, 1.3^2, 1,3^2, 1.6^2)
# log.theta and corresponding coverage
log.theta_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store log.theta values
log.theta_mean <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior means of draws
log.theta_sd <- replicate(B.theta, matrix(data=0, nrow=J, ncol= B.y), simplify=F) # Store posterior sd of drawslog.theta_mean
cov68_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 68% frequency coverage for thetas
cov95_mat <- matrix(data=0, nrow=J, ncol= B.theta) # Store 95% frequency coverage for theta
t1.ov <- Sys.time()
for (i in 1:1) { #length(mu)) {
# Set current model constant hyperparameters
mu <- mu.array[i]
sigsq <- sigsq.array[i]
# Draw set of thetas
t1.sim <- Sys.time()
for (b.theta in 1:B.theta) {
log.theta <- rnorm(J, mu, sqrt(sigsq)) # Sample log.theta
log.theta_mat[, b.theta] <- log.theta
theta <- exp(log.theta)
logTheta.cov_68 <- matrix(data=0, nrow=J, ncol= B.y) # Store 68% coverage for thetas
logTheta.cov_95 <- matrix(data=0, nrow=J, ncol= B.y) # Store 95% coverage for theta
# Draw set of Y for current theta
t1.mcmc <- Sys.time()
for (b.y in 1:B.y) {
Y <- simYgivenTheta(theta, w, N) # Simulate observations
mcmc <- poisson.logn.mcmc(Y, w)
logTheta.draws <- mcmc$logTheta # Sample draws
log.theta_mean[[b.theta]][, b.y] <- apply(logTheta.draws, 1, mean) # Store sample means
log.theta_sd[[b.theta]][, b.y] <- apply(logTheta.draws, 1, sd) # Store sample sd
# Derive 68% and 95% poterior intervals
post.int_68 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.16, 0.84)) }))
post.int_95 <- t(apply(logTheta.draws, 1, function (r) { quantile(r, probs=c(0.025, 0.975)) }))
# Store current coverage
logTheta.cov_68[, b.y] <- (log.theta >= post.int_68[, 1]) & (log.theta <= post.int_68[, 2])
logTheta.cov_95[, b.y] <- (log.theta >= post.int_95[, 1]) & (log.theta <= post.int_95[, 2])
}
t2.mcmc <- Sys.time()
dt.mcmc <- t2.mcmc - t1.mcmc
print(paste("Current theta MCMCs elapsed time", dt.mcmc, sep=": "))
# Compute frequency coverage for log.theta
cov68_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
cov95_mat[, b.theta] <- apply(logTheta.cov_68, 1, mean)
}
t2.sim <- Sys.time()
dt.sim <- t2.sim - t1.sim
print(paste("Simulation elapsed time", dt.sim, sep=": "))
}
t2.ov <- Sys.time()
dt.ov <- t2.ov - t1.ov
print(paste("Total elapsed time", dt.ov, sep=": "))
# Store results in output folder
save(list=c("log.theta_mat", "log.theta_mean", "log.theta_sd",
"cov68_mat", "cov95_mat"), file="./out/task3_out.Rdata")
ÉSys.getenv
?Sys.getenv
fracSec()
?set.seed
a <- c(0, 0)
set.seed(a)
a
set.seed(a)
set.seed(a)
a
fracSec <- function() {
now <- as.vector(as.POSIXct(Sys.time())) / 1000
as.integer(abs(now - trunc(now)) * 10^8)
}
fracSec()
seed <- fracSec()
set.seed(Seed)
set.seed(seed)
seed
set.seed(seed)
seed
set.seed(seed)
seed
